# Atlas UI 3 - Secure Nginx Configuration
# Last Updated: 2025-11-10
#
# SECURITY REQUIREMENTS:
# - This configuration includes  header stripping to prevent header injection attacks
# - Each location that proxies to main-app MUST strip X-User-Email before setting it
# - Without header stripping, attackers can send X-User-Email: admin@company.com and bypass auth
#
# For more details, see docs/reverse-proxy-examples.md

# Upstream names now use the APP_NAME prefix
upstream __APP_NAME__-main-app {
    server __APP_NAME__-main-app:8000;
}

upstream __APP_NAME__-auth-app {
    server __APP_NAME__-main-app:5000;
}

server {
    listen 8080 default_server;
    listen [::]:8080 default_server;
    server_tokens off;

    # Don't add the internal port (8080) to redirects
    port_in_redirect off;

    # Route /login and /getatoken (case-insensitive) to auth-app
    # No authentication required for login endpoints
    location ~* ^/(login|getatoken)$ {
        add_header X-Debug-Location "auth-regex-block" always;
        proxy_pass http://__APP_NAME__-auth-app;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
    }

    # Internal location for auth check
    # This endpoint validates authentication and returns X-User-Email header
    location = /auth-check {
        add_header X-Debug-Location "auth-check-block" always;
        internal;
        proxy_pass http://__APP_NAME__-auth-app/auth;
        proxy_pass_request_body off;
        proxy_set_header Content-Length "";
        proxy_set_header X-Original-URI $request_uri;
        proxy_set_header Cookie $http_cookie;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
    }

    # File download endpoint - requires auth, allows internal IPs
    location /api/files/download/ {
        # Allow internal IP ranges (optional - remove if not needed)
        # satisfy any;
        allow 127.0.0.1;
        allow ::1;
        allow 10.0.0.0/8;
        allow 172.16.0.0/12;
        allow 192.168.0.0/16;
        deny all;

        # Authenticate and get user email
        auth_request /auth-check;
        auth_request_set $auth_user_email $upstream_http_x_user_email;
        error_page 401 = @do_login_redirect;

        # Proxy to main app
        proxy_pass http://__APP_NAME__-main-app;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;

        # CRITICAL SECURITY: Strip client-provided X-User-Email header first
        # Without this, attackers can inject headers to impersonate users
        proxy_set_header X-User-Email "";
        # Now set the authenticated user from auth service
        proxy_set_header X-User-Email $auth_user_email;

        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
    }

    # Everything else to main-app, requires authentication
    # This includes WebSocket connections to /ws
    location / {
        add_header X-Debug-Location "main-location-block" always;

        # Authenticate and get user email
        auth_request /auth-check;
        error_page 401 = @do_login_redirect;
        auth_request_set $auth_user_email $upstream_http_x_user_email;

        # Proxy to main app
        proxy_pass http://__APP_NAME__-main-app;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;

        # CRITICAL SECURITY: Strip client-provided X-User-Email header first
        # This prevents header injection attacks where clients send:
        #   X-User-Email: admin@company.com
        # Without stripping, both the client's header AND the auth header arrive,
        # and the client's header (first) wins in most frameworks.
        proxy_set_header X-User-Email "";
        # Now set the authenticated user from auth service
        proxy_set_header X-User-Email $auth_user_email;

        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_http_version 1.1;

        # WebSocket support
        proxy_set_header Connection "upgrade";
        proxy_set_header Upgrade $http_upgrade;
        proxy_read_timeout 86400;  # 24 hours for long-lived WebSocket connections
    }

    # Named location to handle the redirect for 401 errors from auth_request
    location @do_login_redirect {
        return 302 /login;
    }
}

# SECURITY VERIFICATION CHECKLIST:
# ================================
# Before deploying this configuration:
#
# 1. Verify header stripping is in place:
#    - Search for "proxy_set_header X-User-Email" in this file
#    - Confirm EVERY occurrence is preceded by: proxy_set_header X-User-Email "";
#    - There should be TWO pairs: one in /api/files/download/, one in /
#
# 2. Test header injection protection:
#    curl -H "X-User-Email: attacker@evil.com" \
#         -H "Cookie: valid_session" \
#         https://your-domain.com/api/config
#    Then check backend logs - should see REAL user, not "attacker@evil.com"
#
# 3. Test WebSocket authentication:
#    - Connect to wss://your-domain.com/ws with valid auth
#    - Verify connection succeeds and user is correct
#    - Try with invalid auth, verify connection is rejected (401)
#
# 4. Test direct access is blocked:
#    curl http://__APP_NAME__-main-app:8000/api/config
#    Should timeout or connection refused (network isolation)
#
# 5. Verify auth service is working:
#    - Access /login endpoint
#    - Verify it returns login page
#    - Test valid/invalid credentials
#
# For detailed security documentation, see:
# - docs/reverse-proxy-examples.md
# - docs/archive/security_architecture.md
# - backend/tests/test_security_header_injection.py
