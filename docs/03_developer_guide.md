# Developer's Guide

This guide provides technical details for developers contributing to the Atlas UI 3 project. It covers the architecture, development conventions, and instructions for creating new MCP (Model Context Protocol) servers.

## Architecture Overview

The application is composed of a React frontend and a FastAPI backend, communicating via WebSockets.

### Backend

The backend follows a clean architecture pattern, separating concerns into distinct layers:

*   **`domain`**: Contains the core business logic and data models, with no dependencies on frameworks or external services.
*   **`application`**: Orchestrates the business logic from the domain layer to perform application-specific use cases.
*   **`infrastructure`**: Handles communication with external systems like databases, web APIs, and the file system. It's where adapters for external services are implemented.
*   **`interfaces`**: Defines the contracts (protocols) that the different layers use to communicate, promoting loose coupling.
*   **`routes`**: Defines the HTTP API endpoints.

### Frontend

The frontend is a modern React 19 application built with Vite.

*   **State Management**: Uses React's Context API for managing global state. There is no Redux.
    *   `ChatContext`: Manages the state of the chat, including messages and user selections.
    *   `WSContext`: Manages the WebSocket connection.
*   **Styling**: Uses Tailwind CSS for utility-first styling.

## Development Conventions

To ensure code quality and consistency, please adhere to the following conventions.

*   **Python Package Manager**: **Always** use `uv`. Do not use `pip` or `conda` directly for package management.
*   **Frontend Development**: **Never** use `npm run dev`. It has known WebSocket connectivity issues. Always use `npm run build` to create a production build that the backend will serve.
*   **Backend Development**: **Never** use `uvicorn --reload`. This can cause unexpected issues. Restart the server manually (`python main.py`) to apply changes.
*   **File Naming**: Avoid generic names like `utils.py` or `helpers.py`. Use descriptive names that clearly indicate the file's purpose (e.g., `mcp_tool_manager.py`).
*   **Linting**: Before committing, run the linters to check for style issues:
    *   **Python**: `ruff check backend/`
    *   **Frontend**: `cd frontend && npm run lint`

## Creating an MCP Server

MCP servers are the backbone of the tool system. They are independent processes that expose functions (tools) that the LLM can call.

### 1. Server Structure

A new MCP server is a simple Python script using the `FastMCP` library.

1.  Create a new directory for your server inside `backend/mcp/`.
2.  Inside that directory, create a `main.py` file.

**Example `main.py`:**
```python
from fastmcp import FastMCP
from typing import Dict, Any

mcp = FastMCP(name="MyExampleServer")

@mcp.tool
def my_tool(parameter: str) -> Dict[str, Any]:
    """
    A simple tool that takes a string and returns a dictionary.
    The docstring is used as the tool's description for the LLM.
    """
    # The dictionary you return is the 'results' object.
    return {
        "input_received": parameter,
        "status": "success"
    }

if __name__ == "__main__":
    mcp.run()
```

### 2. The MCP v2 Tool Contract

When a tool is executed, its return value must adhere to a specific JSON structure, known as the "v2 contract." This allows the UI to correctly process and display the results.

The returned JSON object has the following structure:

*   **`results`** (required): A JSON object containing the primary, human-readable result of the tool. This should be concise.
*   **`artifacts`** (optional): A list of files generated by the tool. This is the preferred way to return files or large data blobs. Each artifact is an object with:
    *   `name`: The filename (e.g., `report.html`).
    *   `b64`: The base64-encoded content of the file.
    *   `mime`: The MIME type (e.g., `text/html`, `image/png`).
*   **`display`** (optional): A JSON object that provides hints to the UI on how to display the artifacts, such as whether to open the canvas automatically.

**Example tool returning an artifact:**
```python
import base64

@mcp.tool
def create_html_report(title: str) -> Dict[str, Any]:
    """Generates and returns an HTML report as an artifact."""
    html_content = f"<html><body><h1>{title}</h1></body></html>"
    b64_content = base64.b64encode(html_content.encode()).decode()

    return {
        "results": {"summary": f"Successfully generated report: {title}"},
        "artifacts": [{
            "name": "report.html",
            "b64": b64_content,
            "mime": "text/html"
        }],
        "display": {
            "open_canvas": True,
            "primary_file": "report.html"
        }
    }
```

### 3. Registering the Server

After creating your server, you must register it in `config/overrides/mcp.json`.

```json
{
  "MyExampleServer": {
    "command": ["python", "mcp/MyExampleServer/main.py"],
    "cwd": "backend",
    "groups": ["users"],
    "description": "An example server with a simple tool."
  }
}
```

*   **`command`**: The command to start the server.
*   **`cwd`**: The working directory from which to run the command.
*   **`groups`**: A list of user groups that can access this server's tools.
*   **`description`**: A description of the server shown in the UI.
*   **`auth_token`**: (optional) For HTTP/SSE servers, the bearer token for authentication. Use environment variable substitution like `"${MCP_TOKEN}"` for security.

### 4. Argument Injection

To enhance security and simplify tool development, the backend can automatically inject certain arguments into your tool calls.

*   **`username` Injection (Security Feature)**: If your tool's function signature includes a `username: str` parameter, the backend will **always overwrite** any value for it with the authenticated user's identity. This is a critical security feature to ensure a tool always runs with the correct user context.

*   **File URL Injection**: If your tool accepts a `filename: str` or `file_names: List[str]` parameter, the backend will automatically convert any session files passed by the LLM into secure, temporary URLs. Your tool can then fetch the file content from these URLs. See the "Working with Files" section for more details.

## Working with Files (S3 Storage)

When a user uploads a file, it is stored in an S3-compatible object store. As a tool developer, you do not need to interact with S3 directly. The backend provides a secure mechanism for your tools to access file content.

### The File Access Workflow

1.  **Define Your Tool**: Create a tool that accepts a `filename` (or `file_names`) argument.
    ```python
    @mcp.tool
    def process_file(filename: str) -> Dict[str, Any]:
        # ...
    ```
2.  **Receive a Secure URL**: When the LLM calls your tool, the backend intercepts the call. It replaces the simple filename (e.g., `my_document.pdf`) with a full, temporary URL that points back to the Atlas UI API (e.g., `http://localhost:8000/api/files/download/...`). This URL contains a short-lived security token.
3.  **Fetch the File Content**: Your tool should then make a standard HTTP `GET` request to this URL to download the file's content.

### Example Tool for File Processing

```python
import httpx
from fastmcp import FastMCP
from typing import Dict, Any

mcp = FastMCP(name="FileProcessor")

@mcp.tool
def get_file_size(filename: str) -> Dict[str, Any]:
    """
    Accepts a file URL, downloads the file, and returns its size.
    """
    try:
        with httpx.stream("GET", filename, timeout=30) as response:
            response.raise_for_status()
            content = response.read()
            file_size = len(content)
            
            return {
                "results": {
                    "file_size_bytes": file_size
                }
            }
    except httpx.HTTPStatusError as e:
        return {"error": f"HTTP error fetching file: {e.response.status_code}"}
    except Exception as e:
        return {"error": f"Failed to process file: {str(e)}"}

if __name__ == "__main__":
    mcp.run()
```

This architecture ensures that your tool does not need to handle any S3 credentials, making the system more secure and easier to develop for.

---

### Headless CLI

The application includes a headless CLI for scripting, testing, and interacting with the backend without a UI.

For complete CLI documentation including commands, configuration, examples, and troubleshooting, see **[04_cli.md](04_cli.md)**.

## Adding Custom Canvas Renderers

The canvas panel displays tool-generated files (PDFs, images, HTML). To add support for new file types (e.g., `.stl`, `.obj`, `.ipynb`):

### Canvas Architecture Flow

1. Backend tool returns artifacts → stored in S3 → sends `canvas_files` WebSocket message
2. Frontend receives file metadata (filename, s3_key, type)
3. Frontend fetches file content from `/api/files/download/{s3_key}`
4. `CanvasPanel` renders based on file type

### Steps to Add a New Type

**1. Extend type detection** in `frontend/src/hooks/chat/useFiles.js`:
```javascript
function getFileType(filename) {
  const extension = filename.toLowerCase().split('.').pop()
  if (['stl', 'obj', 'gltf'].includes(extension)) return '3d-model'
  // ... existing types
}
```

**2. Install any required viewer libraries:**
```bash
cd frontend
npm install three @react-three/fiber @react-three/drei
```

**3. Add rendering case** in `frontend/src/components/CanvasPanel.jsx` (around line 211):
```javascript
case '3d-model':
  return (
    <div className="p-4 h-full">
      <STLViewer url={currentFileContent.url} filename={currentFileContent.file.filename} />
    </div>
  );
```

**4. Create the viewer component** (e.g., `frontend/src/components/STLViewer.jsx`).

### Backend Considerations

No backend changes needed. Tools just return artifacts with proper filenames:

```python
return {
    "results": {"summary": "Generated 3D model"},
    "artifacts": [{
        "name": "model.stl",
        "b64": base64.b64encode(stl_bytes).decode(),
        "mime": "model/stl"
    }]
}
```

The `ChatService` automatically processes artifacts, uploads to S3, and sends canvas notifications.
