# Developer's Guide

This guide provides technical details for developers contributing to the Atlas UI 3 project. It covers the architecture, development conventions, and instructions for creating new MCP (Model Context Protocol) servers.

## Architecture Overview

The application is composed of a React frontend and a FastAPI backend, communicating via WebSockets.

### Backend

The backend follows a clean architecture pattern, separating concerns into distinct layers:

*   **`domain`**: Contains the core business logic and data models, with no dependencies on frameworks or external services.
*   **`application`**: Orchestrates the business logic from the domain layer to perform application-specific use cases.
*   **`infrastructure`**: Handles communication with external systems like databases, web APIs, and the file system. It's where adapters for external services are implemented.
*   **`interfaces`**: Defines the contracts (protocols) that the different layers use to communicate, promoting loose coupling.
*   **`routes`**: Defines the HTTP API endpoints.

### Frontend

The frontend is a modern React 19 application built with Vite.

*   **State Management**: Uses React's Context API for managing global state. There is no Redux.
    *   `ChatContext`: Manages the state of the chat, including messages and user selections.
    *   `WSContext`: Manages the WebSocket connection.
*   **Styling**: Uses Tailwind CSS for utility-first styling.

## Development Conventions

To ensure code quality and consistency, please adhere to the following conventions.

*   **Python Package Manager**: **Always** use `uv`. Do not use `pip` or `conda` directly for package management.
*   **Frontend Development**: **Never** use `npm run dev`. It has known WebSocket connectivity issues. Always use `npm run build` to create a production build that the backend will serve.
*   **Backend Development**: **Never** use `uvicorn --reload`. This can cause unexpected issues. Restart the server manually (`python main.py`) to apply changes.
*   **File Naming**: Avoid generic names like `utils.py` or `helpers.py`. Use descriptive names that clearly indicate the file's purpose (e.g., `mcp_tool_manager.py`).
*   **Linting**: Before committing, run the linters to check for style issues:
    *   **Python**: `ruff check backend/`
    *   **Frontend**: `cd frontend && npm run lint`

## Creating an MCP Server

MCP servers are the backbone of the tool system. They are independent processes that expose functions (tools) that the LLM can call.

### 1. Server Structure

A new MCP server is a simple Python script using the `FastMCP` library.

1.  Create a new directory for your server inside `backend/mcp/`.
2.  Inside that directory, create a `main.py` file.

**Example `main.py`:**
```python
from fastmcp import FastMCP
from typing import Dict, Any

mcp = FastMCP(name="MyExampleServer")

@mcp.tool
def my_tool(parameter: str) -> Dict[str, Any]:
    """
    A simple tool that takes a string and returns a dictionary.
    The docstring is used as the tool's description for the LLM.
    """
    # The dictionary you return is the 'results' object.
    return {
        "input_received": parameter,
        "status": "success"
    }

if __name__ == "__main__":
    mcp.run()
```

### 2. The MCP v2 Tool Contract

When a tool is executed, its return value must adhere to a specific JSON structure, known as the "v2 contract." This allows the UI to correctly process and display the results.

The returned JSON object has the following structure:

*   **`results`** (required): A JSON object containing the primary, human-readable result of the tool. This should be concise.
*   **`artifacts`** (optional): A list of files generated by the tool. This is the preferred way to return files or large data blobs. Each artifact is an object with:
    *   `name`: The filename (e.g., `report.html`).
    *   `b64`: The base64-encoded content of the file.
    *   `mime`: The MIME type (e.g., `text/html`, `image/png`).
    *   `viewer`: The preferred viewer type (e.g., `html`, `image`, `pdf`, `iframe`).
*   **`display`** (optional): A JSON object that provides hints to the UI on how to display the artifacts, such as whether to open the canvas automatically.

**Example tool returning an artifact:**
```python
import base64

@mcp.tool
def create_html_report(title: str) -> Dict[str, Any]:
    """Generates and returns an HTML report as an artifact."""
    html_content = f"<html><body><h1>{title}</h1></body></html>"
    b64_content = base64.b64encode(html_content.encode()).decode()

    return {
        "results": {"summary": f"Successfully generated report: {title}"},
        "artifacts": [{
            "name": "report.html",
            "b64": b64_content,
            "mime": "text/html",
            "viewer": "html"
        }],
        "display": {
            "open_canvas": True,
            "primary_file": "report.html"
        }
    }
```

#### Iframe Support for External Content

MCP tools can embed external content using iframes in two ways:

**Approach 1: Direct Iframe via Display Config**

Use this when you want to display an external URL directly without wrapping it in HTML:

```python
@mcp.tool
def show_dashboard() -> Dict[str, Any]:
    """Display an external dashboard in the canvas."""
    return {
        "results": {"summary": "Dashboard loaded"},
        "artifacts": [],
        "display": {
            "type": "iframe",
            "url": "https://example.com/dashboard",
            "title": "Analytics Dashboard",
            "sandbox": "allow-scripts allow-same-origin",
            "open_canvas": True
        }
    }
```

**Approach 2: HTML Artifact with Embedded Iframe**

Use this when you want to create a custom HTML page that includes one or more iframes:

```python
@mcp.tool
def create_page_with_iframe() -> Dict[str, Any]:
    """Create an HTML page with embedded iframe."""
    html_content = """
    <html>
    <body>
        <h1>External Content</h1>
        <iframe 
            src="https://example.com" 
            width="100%" 
            height="600px"
            sandbox="allow-scripts allow-same-origin">
        </iframe>
    </body>
    </html>
    """
    b64_content = base64.b64encode(html_content.encode()).decode()
    
    return {
        "results": {"summary": "Page created"},
        "artifacts": [{
            "name": "page.html",
            "b64": b64_content,
            "mime": "text/html",
            "viewer": "html"
        }],
        "display": {
            "open_canvas": True,
            "primary_file": "page.html"
        }
    }
```

**Security Considerations for Iframes:**

*   Iframes are automatically sandboxed for security
*   Default sandbox permissions: `"allow-scripts allow-same-origin"` (restrictive by default)
*   Tools can specify custom sandbox attributes via the `sandbox` field to add permissions like `"allow-forms"` if needed
*   Only whitelisted iframe attributes are preserved: `src`, `sandbox`, `allow`, `allowfullscreen`, `frameborder`, `scrolling`
*   All HTML content is sanitized with DOMPurify before rendering

### 3. Registering the Server

After creating your server, you must register it in `config/overrides/mcp.json`.

```json
{
  "MyExampleServer": {
    "command": ["python", "mcp/MyExampleServer/main.py"],
    "cwd": "backend",
    "groups": ["users"],
    "description": "An example server with a simple tool."
  }
}
```

*   **`command`**: The command to start the server.
*   **`cwd`**: The working directory from which to run the command.
*   **`groups`**: A list of user groups that can access this server's tools.
*   **`description`**: A description of the server shown in the UI.
*   **`auth_token`**: (optional) For HTTP/SSE servers, the bearer token for authentication. Use environment variable substitution like `"${MCP_TOKEN}"` for security.

### 4. Argument Injection

To enhance security and simplify tool development, the backend can automatically inject certain arguments into your tool calls.

*   **`username` Injection (Security Feature)**: If your tool's function signature includes a `username: str` parameter, the backend will **always overwrite** any value for it with the authenticated user's identity. This is a critical security feature to ensure a tool always runs with the correct user context.

*   **File URL Injection**: If your tool accepts a `filename: str` or `file_names: List[str]` parameter, the backend will automatically convert any session files passed by the LLM into secure, temporary URLs. Your tool can then fetch the file content from these URLs. See the "Working with Files" section for more details.

## Working with Files (S3 Storage)

When a user uploads a file, it is stored in an S3-compatible object store. As a tool developer, you do not need to interact with S3 directly. The backend provides a secure mechanism for your tools to access file content.

### The File Access Workflow

1.  **Define Your Tool**: Create a tool that accepts a `filename` (or `file_names`) argument.
    ```python
    @mcp.tool
    def process_file(filename: str) -> Dict[str, Any]:
        # ...
    ```
2.  **Receive a Secure URL**: When the LLM calls your tool, the backend intercepts the call. It replaces the simple filename (e.g., `my_document.pdf`) with a full, temporary URL that points back to the Atlas UI API (e.g., `http://localhost:8000/api/files/download/...`). This URL contains a short-lived security token.
3.  **Fetch the File Content**: Your tool should then make a standard HTTP `GET` request to this URL to download the file's content.

### Example Tool for File Processing

```python
import httpx
from fastmcp import FastMCP
from typing import Dict, Any

mcp = FastMCP(name="FileProcessor")

@mcp.tool
def get_file_size(filename: str) -> Dict[str, Any]:
    """
    Accepts a file URL, downloads the file, and returns its size.
    """
    try:
        with httpx.stream("GET", filename, timeout=30) as response:
            response.raise_for_status()
            content = response.read()
            file_size = len(content)
            
            return {
                "results": {
                    "file_size_bytes": file_size
                }
            }
    except httpx.HTTPStatusError as e:
        return {"error": f"HTTP error fetching file: {e.response.status_code}"}
    except Exception as e:
        return {"error": f"Failed to process file: {str(e)}"}

if __name__ == "__main__":
    mcp.run()
```

This architecture ensures that your tool does not need to handle any S3 credentials, making the system more secure and easier to develop for.

## Progress Updates and Intermediate Results

Long-running MCP tools can now send intermediate updates to the frontend during execution, providing users with real-time feedback. This includes:

- **Canvas Updates**: Display HTML visualizations, plots, or images in the canvas panel as the tool progresses
- **System Messages**: Add rich, formatted messages to the chat history to show what's happening at each stage
- **Progressive Artifacts**: Send file artifacts as they're generated, rather than only at the end

### Basic Progress Reporting

FastMCP provides a `Context` object that tools can use to report progress:

```python
from fastmcp import FastMCP, Context

mcp = FastMCP("MyServer")

@mcp.tool
async def long_task(
    steps: int = 5,
    ctx: Context | None = None
) -> dict:
    """A tool that reports progress."""
    
    for i in range(steps):
        # Standard progress reporting
        if ctx:
            await ctx.report_progress(
                progress=i,
                total=steps,
                message=f"Processing step {i+1} of {steps}"
            )
        
        # Do work...
        await asyncio.sleep(1)
    
    return {"results": {"status": "completed", "steps": steps}}
```

This shows a progress bar in the UI with percentage and message updates.

### Enhanced Progress Updates

To send richer updates (canvas content, system messages, or artifacts), encode structured data in the progress message with the `MCP_UPDATE:` prefix:

#### 1. Canvas Updates

Display HTML content in the canvas panel during execution:

```python
import json

@mcp.tool
async def task_with_visualization(
    steps: int = 5,
    ctx: Context | None = None
) -> dict:
    """Shows visual progress in the canvas."""
    
    for step in range(1, steps + 1):
        # Create HTML visualization
        html_content = f"""
        <html>
          <body style="padding: 20px;">
            <h1>Processing Step {step}/{steps}</h1>
            <div style="width: 100%; background: #eee; height: 30px;">
              <div style="width: {(step/steps)*100}%; background: #4CAF50; height: 100%;"></div>
            </div>
          </body>
        </html>
        """
        
        # Send canvas update
        if ctx:
            update_payload = {
                "type": "canvas_update",
                "content": html_content,
                "progress_message": f"Step {step}/{steps}"
            }
            await ctx.report_progress(
                progress=step,
                total=steps,
                message=f"MCP_UPDATE:{json.dumps(update_payload)}"
            )
    
    return {"results": {"status": "completed"}}
```

#### 2. System Messages

Add informative messages to the chat history:

```python
@mcp.tool
async def task_with_status_updates(
    stages: list[str],
    ctx: Context | None = None
) -> dict:
    """Reports status updates as chat messages."""
    
    for i, stage in enumerate(stages, 1):
        # Do work for this stage...
        await process_stage(stage)
        
        # Send system message
        if ctx:
            update_payload = {
                "type": "system_message",
                "message": f"**{stage}** completed successfully",
                "subtype": "success",  # or "info", "warning", "error"
                "progress_message": f"Completed {stage}"
            }
            await ctx.report_progress(
                progress=i,
                total=len(stages),
                message=f"MCP_UPDATE:{json.dumps(update_payload)}"
            )
    
    return {"results": {"status": "completed", "stages": len(stages)}}
```

#### 3. Progressive Artifacts

Send file artifacts as they're generated:

```python
import base64

@mcp.tool
async def task_with_intermediate_files(
    files_to_generate: int = 3,
    ctx: Context | None = None
) -> dict:
    """Generates and displays files progressively."""
    
    for file_num in range(1, files_to_generate + 1):
        # Generate file content
        html_content = f"<html><body><h1>Result {file_num}</h1></body></html>"
        
        # Send artifact
        if ctx:
            artifact_data = {
                "type": "artifacts",
                "artifacts": [
                    {
                        "name": f"result_{file_num}.html",
                        "b64": base64.b64encode(html_content.encode()).decode(),
                        "mime": "text/html",
                        "size": len(html_content),
                        "description": f"Intermediate result {file_num}",
                        "viewer": "html"
                    }
                ],
                "display": {
                    "open_canvas": True,
                    "primary_file": f"result_{file_num}.html",
                    "mode": "replace"
                },
                "progress_message": f"Generated file {file_num}"
            }
            await ctx.report_progress(
                progress=file_num,
                total=files_to_generate,
                message=f"MCP_UPDATE:{json.dumps(artifact_data)}"
            )
    
    return {"results": {"files_generated": files_to_generate}}
```

### Update Types Reference

| Type | Fields | Description |
|------|--------|-------------|
| `canvas_update` | `content` (HTML string), `progress_message` (optional) | Displays HTML content in the canvas panel |
| `system_message` | `message` (string), `subtype` (info/success/warning/error), `progress_message` (optional) | Adds a formatted message to chat history |
| `artifacts` | `artifacts` (list), `display` (object), `progress_message` (optional) | Sends file artifacts with display hints |

### Example: Complete Demo Server

See `/backend/mcp/progress_updates_demo/` for a complete working example with three tools demonstrating all update types. To try it:

1. Add the server to your `config/overrides/mcp.json`:
```json
{
  "progress_updates_demo": {
    "command": ["python", "mcp/progress_updates_demo/main.py"],
    "cwd": "backend",
    "groups": ["users"],
    "description": "Demo server showing enhanced progress updates"
  }
}
```

2. Restart the backend and ask: "Show me a task with canvas updates"

## Adding Custom Canvas Renderers

The canvas panel displays tool-generated files (PDFs, images, HTML). To add support for new file types (e.g., `.stl`, `.obj`, `.ipynb`):

### Canvas Architecture Flow

1. Backend tool returns artifacts → stored in S3 → sends `canvas_files` WebSocket message
2. Frontend receives file metadata (filename, s3_key, type)
3. Frontend fetches file content from `/api/files/download/{s3_key}`
4. `CanvasPanel` renders based on file type

### Steps to Add a New Type

**1. Extend type detection** in `frontend/src/hooks/chat/useFiles.js`:
```javascript
function getFileType(filename) {
  const extension = filename.toLowerCase().split('.').pop()
  if (['stl', 'obj', 'gltf'].includes(extension)) return '3d-model'
  // ... existing types
}
```

**2. Install any required viewer libraries:**
```bash
cd frontend
npm install three @react-three/fiber @react-three/drei
```

**3. Add rendering case** in `frontend/src/components/CanvasPanel.jsx` (around line 211):
```javascript
case '3d-model':
  return (
    <div className="p-4 h-full">
      <STLViewer url={currentFileContent.url} filename={currentFileContent.file.filename} />
    </div>
  );
```

**4. Create the viewer component** (e.g., `frontend/src/components/STLViewer.jsx`).

### Backend Considerations

No backend changes needed. Tools just return artifacts with proper filenames:

```python
return {
    "results": {"summary": "Generated 3D model"},
    "artifacts": [{
        "name": "model.stl",
        "b64": base64.b64encode(stl_bytes).decode(),
        "mime": "model/stl"
    }]
}
```

The `ChatService` automatically processes artifacts, uploads to S3, and sends canvas notifications.
