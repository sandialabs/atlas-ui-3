# Creating an MCP Server

Last updated: 2026-01-19

MCP servers are the backbone of the tool system. They are independent processes that expose functions (tools) that the LLM can call.

## 1. Server Structure

A new MCP server is a simple Python script using the `FastMCP` library.

1.  Create a new directory for your server inside `backend/mcp/`.
2.  Inside that directory, create a `main.py` file.

**Example `main.py`:**
```python
from fastmcp import FastMCP
from typing import Dict, Any

mcp = FastMCP(name="MyExampleServer")

@mcp.tool
def my_tool(parameter: str) -> Dict[str, Any]:
    """
    A simple tool that takes a string and returns a dictionary.
    The docstring is used as the tool's description for the LLM.
    """
    # The dictionary you return is the 'results' object.
    return {
        "input_received": parameter,
        "status": "success"
    }

if __name__ == "__main__":
    mcp.run()
```

## 2. The MCP v2 Tool Contract

When a tool is executed, its return value must adhere to a specific JSON structure, known as the "v2 contract." This allows the UI to correctly process and display the results.

The returned JSON object has the following structure:

*   **`results`** (required): A JSON object containing the primary, human-readable result of the tool. This should be concise.
*   **`artifacts`** (optional): A list of files generated by the tool. This is the preferred way to return files or large data blobs. Each artifact is an object with:
    *   `name`: The filename (e.g., `report.html`).
    *   `b64`: The base64-encoded content of the file.
    *   `mime`: The MIME type (e.g., `text/html`, `image/png`).
*   **`display`** (optional): A JSON object that provides hints to the UI on how to display the artifacts, such as whether to open the canvas automatically.

**Example tool returning an artifact:**
```python
import base64

@mcp.tool
def create_html_report(title: str) -> Dict[str, Any]:
    """Generates and returns an HTML report as an artifact."""
    html_content = f"<html><body><h1>{title}</h1></body></html>"
    b64_content = base64.b64encode(html_content.encode()).decode()

    return {
        "results": {"summary": f"Successfully generated report: {title}"},
        "artifacts": [{
            "name": "report.html",
            "b64": b64_content,
            "mime": "text/html"
        }],
        "display": {
            "open_canvas": True,
            "primary_file": "report.html"
        }
    }
```

For more details on how the canvas chooses viewers (including iframe support for external dashboards and embedded HTML), see `docs/developer/canvas-renderers.md`.

## Displaying External Content with Iframes

MCP tools can display external content (dashboards, visualizations, web applications) using iframes in two ways:

### Method 1: Direct Iframe Display

Return an iframe configuration in the `display` object:

```python
@mcp.tool
def show_dashboard() -> Dict[str, Any]:
    """Display an external dashboard in the canvas panel."""
    return {
        "results": {
            "content": "Dashboard displayed in canvas panel"
        },
        "artifacts": [],
        "display": {
            "open_canvas": True,
            "type": "iframe",
            "url": "https://dashboard.example.com",
            "title": "Analytics Dashboard",
            "sandbox": "allow-scripts allow-same-origin",
            "mode": "replace"
        }
    }
```

### Method 2: HTML Artifact with Embedded Iframes

Return HTML content containing `<iframe>` tags:

```python
import base64

@mcp.tool
def create_embedded_viewer() -> Dict[str, Any]:
    """Create HTML with embedded external content."""
    html_content = """<!DOCTYPE html>
<html>
<head>
    <style>
        body { margin: 0; padding: 20px; font-family: Arial, sans-serif; }
        .iframe-container { width: 100%; height: 600px; border: 2px solid #444; }
    </style>
</head>
<body>
    <h1>External Content</h1>
    <div class="iframe-container">
        <iframe src="https://example.com"
                width="100%"
                height="100%"
                sandbox="allow-scripts allow-same-origin">
        </iframe>
    </div>
</body>
</html>"""

    html_base64 = base64.b64encode(html_content.encode('utf-8')).decode('utf-8')

    return {
        "results": {
            "content": "HTML with embedded iframe created"
        },
        "artifacts": [{
            "name": "viewer.html",
            "b64": html_base64,
            "mime": "text/html",
            "size": len(html_content.encode('utf-8')),
            "description": "HTML page with embedded iframe",
            "viewer": "html"
        }],
        "display": {
            "open_canvas": True,
            "primary_file": "viewer.html",
            "mode": "replace",
            "viewer_hint": "html"
        }
    }
```

### CRITICAL: CSP Configuration Required

**External iframe URLs will be blocked by the browser unless properly configured in the application's Content Security Policy.**

For any external URL you want to display in an iframe, the system administrator must add that domain to the `SECURITY_CSP_VALUE` environment variable's `frame-src` directive.

**Example `.env` configuration:**
```bash
# To allow https://dashboard.example.com and https://www.sandia.gov/
SECURITY_CSP_VALUE="default-src 'self'; img-src 'self' data: blob:; script-src 'self'; style-src 'self' 'unsafe-inline'; connect-src 'self'; frame-src 'self' blob: data: https://dashboard.example.com https://www.sandia.gov/; frame-ancestors 'self'"
```

**Best Practice:** Document which external URLs your MCP server uses in your server's `description` field in `mcp.json`, so administrators know which domains need to be added to the CSP configuration.

See the `backend/mcp/ui-demo/main.py` file for working examples of both iframe patterns.

## 3. Registering the Server

After creating your server, you must register it in `config/overrides/mcp.json`.

```json
{
  "MyExampleServer": {
    "command": ["python", "mcp/MyExampleServer/main.py"],
    "cwd": "backend",
    "groups": ["users"],
    "description": "An example server with a simple tool."
  }
}
```

*   **`command`**: The command to start the server.
*   **`cwd`**: The working directory from which to run the command.
*   **`groups`**: A list of user groups that can access this server's tools.
*   **`description`**: A description of the server shown in the UI.
*   **`auth_token`**: (optional) For HTTP/SSE servers, the bearer token for authentication. Use environment variable substitution like `"${MCP_TOKEN}"` for security.

## 4. Argument Injection

To enhance security and simplify tool development, the backend can automatically inject certain arguments into your tool calls.

*   **`username` Injection (Security Feature)**: If your tool's function signature includes a `username: str` parameter, the backend will **always overwrite** any value for it with the authenticated user's identity. This is a critical security feature to ensure a tool always runs with the correct user context.

*   **File URL Injection**: If your tool accepts a `filename: str` or `file_names: List[str]` parameter, the backend will automatically convert any session files passed by the LLM into secure, temporary URLs. Your tool can then fetch the file content from these URLs. See the [Working with Files](working-with-files.md) guide for more details.
